<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Monochrome Image Viewer with Line Profiles</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body,
      html {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%; /* Ensure body takes full viewport height */
        font-family: Arial, sans-serif;
      }
      #mainContainer {
        display: flex;
        align-items: stretch;
        width: 100%; /* Ensure main container takes full width */
        height: 100%; /* Ensure main container takes full height */
      }
      #imageContainer {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #loadedImage {
        max-width: 100%;
        max-height: 100%;
        // object-fit: contain;
      }
      #lineProfiles {
        display: flex;
        flex-direction: column;
      }

      #spinner {
        position: absolute;
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      canvas {
        image-rendering: optimizeSpeed;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: -o-crisp-edges;
        image-rendering: crisp-edges;
        -ms-interpolation-mode: nearest-neighbor;
      }
      .grid-container {
        height: 100%;
        display: grid;
        grid-template-columns: auto 100px;
        grid-template-rows: auto 100px;
        flex-grow: 1; /* added */
        min-height: 0; /* here */
      }
    </style>
  </head>
  <body>
    <div id="spinner"></div>
    <div class="mainContainer">
      <div class="grid-container">
        <canvas id="loadedImage" style="display: none"></canvas>
        <canvas id="yProfile" style="display: none" width="100"></canvas>
        <canvas id="xProfile" style="display: none" height="100"></canvas>
      </div>
    </div>

    <script>
      const vscode = acquireVsCodeApi();
      const spinner = document.getElementById("spinner");

      const canvas = document.getElementById("loadedImage");
      const ctx = canvas.getContext("2d");

      const xProfileCanvas = document.getElementById("xProfile");
      const xProfileCtx = xProfileCanvas.getContext("2d");
      const yProfileCanvas = document.getElementById("yProfile");
      const yProfileCtx = yProfileCanvas.getContext("2d");

      let offscreenCanvas, offscreenCtx;
      let imageWidth, imageHeight;
      let currentTransform = d3.zoomIdentity;
      let originalData = null;
      let originalDataT = null;
      let scaleFactor = 1;

      function drawLineProfile(profileCtx, profileData, isHorizontal) {
        // set canvas size
        profileCtx.clearRect(
          0,
          0,
          profileCtx.canvas.width,
          profileCtx.canvas.height
        );

        // Find max value for scaling
        const maxVal = Math.max(...profileData);

        // Draw background grid
        profileCtx.strokeStyle = "#e0e0e0";
        profileCtx.beginPath();
        if (isHorizontal) {
          for (let i = 0; i <= 5; i++) {
            const y = profileCtx.canvas.height * (1 - i / 5);
            profileCtx.moveTo(0, y);
            profileCtx.lineTo(profileCtx.canvas.width, y);
          }
        } else {
          for (let i = 0; i <= 5; i++) {
            const x = profileCtx.canvas.width * (1 - i / 5);
            profileCtx.moveTo(x, 0);
            profileCtx.lineTo(x, profileCtx.canvas.height);
          }
        }
        profileCtx.stroke();

        // Draw profile line
        profileCtx.strokeStyle = "white";
        profileCtx.beginPath();
        if (isHorizontal) {
          profileData.forEach((val, index) => {
            const x =
              (index / (profileData.length - 1)) * profileCtx.canvas.width;
            const y = profileCtx.canvas.height * (1 - val / maxVal);
            if (index === 0) {
              profileCtx.moveTo(x, y);
            } else {
              const prevX =
                ((index - 1) / (profileData.length - 1)) *
                profileCtx.canvas.width;
              const prevY =
                profileCtx.canvas.height *
                (1 - profileData[index - 1] / maxVal);
              profileCtx.lineTo(x, prevY);
              profileCtx.lineTo(x, y);
            }
          });
        } else {
          profileData.forEach((val, index) => {
            const x = profileCtx.canvas.width * (1 - val / maxVal);
            const y =
              (index / (profileData.length - 1)) * profileCtx.canvas.height;
            if (index === 0) {
              profileCtx.moveTo(x, y);
            } else {
              const prevX =
                profileCtx.canvas.width * (1 - profileData[index - 1] / maxVal);
              const prevY =
                ((index - 1) / (profileData.length - 1)) *
                profileCtx.canvas.height;
              profileCtx.lineTo(prevX, y);
              profileCtx.lineTo(x, y);
            }
          });
        }
        profileCtx.stroke();
      }

      function renderMonochromeImage(
        normalizedData,
        width,
        height,
        originalPixelData
      ) {
        imageWidth = width;
        imageHeight = height;
        originalData = originalPixelData;

        // Precompute the transposed data for vertical profiles
        originalDataT = new Array(width);
        for (let x = 0; x < width; x++) {
          originalDataT[x] = new Array(height);
          for (let y = 0; y < height; y++) {
            originalDataT[x][y] = originalData[y * width + x];
          }
        }

        const pixelData = normalizedData;
        const imageData = new ImageData(width, height);
        const data = imageData.data;

        for (let i = 0; i < pixelData.length; i++) {
          const pixelValue = pixelData[i];
          const index = i * 4;
          data[index] = pixelValue;
          data[index + 1] = pixelValue;
          data[index + 2] = pixelValue;
          data[index + 3] = 255;
        }

        canvas.width = width;
        canvas.height = height;
        
        offscreenCanvas = document.createElement("canvas");
        offscreenCanvas.width = width;
        offscreenCanvas.height = height;
        offscreenCtx = offscreenCanvas.getContext("2d");
        offscreenCtx.putImageData(imageData, 0, 0);

        ctx.drawImage(offscreenCanvas, 0, 0);
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.imageSmoothingEnabled = false;

        // rescale the canvas to fit the window
        scaleFactor = Math.min(
          window.innerWidth / width,
          window.innerHeight / height
        );
        canvas.style.width = `${width * scaleFactor - 100}px`;
        canvas.style.height = `${height * scaleFactor - 100}px`;

        spinner.style.display = "none";
        canvas.style.display = "block";
        xProfileCanvas.style.display = "block";
        yProfileCanvas.style.display = "block";

        xProfileCanvas.width = canvas.getBoundingClientRect().width;
        yProfileCanvas.height = canvas.getBoundingClientRect().height;

        // Add mousemove event listener to show pixel value and line profiles
        canvas.addEventListener("mousemove", (event) => {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const x = Math.floor((event.clientX - rect.left) * scaleX);
          const y = Math.floor((event.clientY - rect.top) * scaleY);

          // Apply the current transform to get the actual pixel coordinates
          const transformedX = Math.floor(
            (x - currentTransform.x) / currentTransform.k
          );
          const transformedY = Math.floor(
            (y - currentTransform.y) / currentTransform.k
          );

          // current x width and y height in terms of pixels in the image
          const xWidth = Math.floor(imageWidth / currentTransform.k);
          const yHeight = Math.floor(imageHeight / currentTransform.k);

          // left and top of the image in terms of pixels in the image
          const left = Math.floor(-currentTransform.x / currentTransform.k);
          const top = Math.floor(-currentTransform.y / currentTransform.k);

          if (
            transformedX >= 0 &&
            transformedX < width &&
            transformedY >= 0 &&
            transformedY < height
          ) {
            // Extract X and Y line profiles of region shown in the canvas
            const xProfile = originalData.slice(
              transformedY * width + left,
              transformedY * width + left + xWidth + 2
            );
            const yProfile = originalDataT[transformedX].slice(
              top,
              top + yHeight + 2
            );

            // Draw line profiles
            drawLineProfile(xProfileCtx, xProfile, true);
            drawLineProfile(yProfileCtx, yProfile, false);

            console.log(
              "Pixel value:",
              originalData[transformedY * width + transformedX],
              "at:",
              transformedX,
              transformedY
            );
          }
        });
      }

      function setupZoom() {
        const zoom = d3
          .zoom()
          .scaleExtent([1, 100]) // Zoom range
          .on("zoom", (event) => {
            // console.log("Zoom event", event.transform);
            let transform = event.transform;
            currentTransform = transform;

            // Constrain translation to prevent panning out of canvas
            const maxX = Math.max(0, (canvas.width - imageWidth * transform.k) / 2);
            const maxY = Math.max(0, (canvas.height - imageHeight * transform.k) / 2);
            transform.x = Math.min(maxX, Math.max(transform.x, canvas.width - imageWidth * transform.k - maxX));
            transform.y = Math.min(maxY, Math.max(transform.y, canvas.height - imageHeight * transform.k - maxY));

            // Compute visible canvas size and resample from the original resolution
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(transform.x/scaleFactor, transform.y/scaleFactor);
            ctx.scale(transform.k, transform.k);

            // Redraw the original image with the appropriate transformation
            ctx.drawImage(offscreenCanvas, 0, 0, imageWidth, imageHeight);
            ctx.restore();
          });

        d3.select(canvas).call(zoom);
      }

      window.addEventListener("message", (event) => {
        const message = event.data;
        if (message.command === "loadData") {
          requestAnimationFrame(() => {
            renderMonochromeImage(
              message.data,
              message.width,
              message.height,
              message.originalData,
              message.header
            );
            setupZoom(); // Initialize zoom after rendering
          });
        }
      });

      vscode.postMessage({ command: "ready" });
    </script>
  </body>
</html>
