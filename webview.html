<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Monochrome Image Viewer with Line Profiles</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>
  <body>
    <div style="display: flex; align-items: center; height: 100%">
        <div id="spinner"></div>
    </div>
    <div class="mainContainer" style="display: none">
        <div id="imageGridContainer" class="grid-container">
            <canvas id="loadedImage"></canvas>
            <canvas id="yProfile" width="100"></canvas>
            <canvas id="xProfile" height="100"></canvas>
            <div class="info-corner">
                <p id="headerTab" class="toggle-button">header &gt;</p>
                <p id="pixelValue"></p>
                <p id="pixelPosition"></p>
            </div>
        </div>
        <div id="headerGridContainer" class="grid-container" style="display: none;">
            <div class="header-container">
                <table id="headerTable"></table>
            </div>
            <div></div>
            <div></div>
            <div class="info-corner">
                <p id="returnButton" class="toggle-button">&lt; image</p>
            </div>
        </div>
    </div>


    <script>
      const vscode = acquireVsCodeApi();
      const spinner = document.getElementById("spinner");

      const canvas = document.getElementById("loadedImage");
      const ctx = canvas.getContext("2d");

      const xProfileCanvas = document.getElementById("xProfile");
      const xProfileCtx = xProfileCanvas.getContext("2d");
      const yProfileCanvas = document.getElementById("yProfile");
      const yProfileCtx = yProfileCanvas.getContext("2d");

      let offscreenCanvas, offscreenCtx;
      let imageWidth, imageHeight;
      let currentTransform = d3.zoomIdentity;
      let imageData = null;
      let imageDataT = null;
      let normalizedData = null;
      let scaleFactor = 1;
      let headerData = {};

      const mainContainer = document.querySelector(".mainContainer");
      const headerTab = document.getElementById("headerTab");
      const headerGridContainer = document.getElementById("headerGridContainer");
      const imageGridContainer = document.getElementById("imageGridContainer");
      const returnButton = document.getElementById("returnButton");
      const headerTable = document.getElementById("headerTable");

      headerTab.addEventListener("click", () => {
        imageGridContainer.style.display = "none";
        headerGridContainer.style.display = "grid";
      });

      returnButton.addEventListener("click", () => {
        headerGridContainer.style.display = "none";
        imageGridContainer.style.display = "grid";
      });

      function displayHeaderTable(data) {
        headerTable.innerHTML = "";
        for (const [key, value] of Object.entries(data)) {
          const row = document.createElement("tr");
          const keyCell = document.createElement("td");
          const valueCell = document.createElement("td");
          keyCell.textContent = key;
          valueCell.textContent = value;
          row.appendChild(keyCell);
          row.appendChild(valueCell);
          headerTable.appendChild(row);
        }
      }

      function drawLineProfile(profileCtx, profileData, isHorizontal, offset) {
        // set canvas size
        profileCtx.clearRect(
          0,
          0,
          profileCtx.canvas.width,
          profileCtx.canvas.height
        );

        // Find max value for scaling
        const maxVal = Math.max(...profileData);

        // Draw background grid
        profileCtx.strokeStyle = "#e0e0e0";
        profileCtx.beginPath();
        if (isHorizontal) {
          for (let i = 0; i <= 5; i++) {
            const y = profileCtx.canvas.height * (1 - i / 5);
            profileCtx.moveTo(0, y);
            profileCtx.lineTo(profileCtx.canvas.width, y);
          }
        } else {
          for (let i = 0; i <= 5; i++) {
            const x = profileCtx.canvas.width * (1 - i / 5);
            profileCtx.moveTo(x, 0);
            profileCtx.lineTo(x, profileCtx.canvas.height);
          }
        }
        profileCtx.stroke();

        // Draw profile line
        profileCtx.strokeStyle = "white";
        profileCtx.beginPath();
        if (isHorizontal) {
          profileData.forEach((val, index) => {
            const x =
              ((index - offset) / (profileData.length - 1)) *
              profileCtx.canvas.width;
            const y = profileCtx.canvas.height * (1 - val / maxVal);
            if (index === 0) {
              profileCtx.moveTo(x, y);
            } else {
              const prevY =
                profileCtx.canvas.height *
                (1 - profileData[index - 1] / maxVal);
              profileCtx.lineTo(x, prevY);
              profileCtx.lineTo(x, y);
            }
          });
        } else {
          profileData.forEach((val, index) => {
            const x = profileCtx.canvas.width * (1 - val / maxVal);
            const y =
              ((index - offset) / (profileData.length - 1)) *
              profileCtx.canvas.height;
            if (index === 0) {
              profileCtx.moveTo(x, y);
            } else {
              const prevX =
                profileCtx.canvas.width * (1 - profileData[index - 1] / maxVal);
              profileCtx.lineTo(prevX, y);
              profileCtx.lineTo(x, y);
            }
          });
        }
        profileCtx.stroke();
      }

      async function renderMonochromeImage(fileUri) {
        // Step 1: Read the FITS file
        console.time("renderMonochromeImage");
        const response = await fetch(fileUri);
        const arrayBuffer = await response.arrayBuffer();
        console.timeLog("renderMonochromeImage", "FITS file loaded");

        // Step 2: Create DataView for parsing
        const dataView = new DataView(arrayBuffer);
        console.timeLog("renderMonochromeImage", "DataView created");

        // Step 3: Parse the FITS header and data
        [headerData, normalizedData, imageWidth, imageHeight, imageData] =
          parseFITSImage(arrayBuffer, dataView);

        displayHeaderTable(headerData);

        console.timeLog("renderMonochromeImage", "FITS header and data parsed");

        // Step 4: Precompute the transposed data for vertical profiles
        imageDataT = new Array(imageWidth);
        for (let x = 0; x < imageWidth; x++) {
          imageDataT[x] = new Array(imageHeight);
          for (let y = 0; y < imageHeight; y++) {
            imageDataT[x][y] = imageData[y * imageWidth + x];
          }
        }

        console.timeLog("renderMonochromeImage", "Data transposed");

        // Step 5: Compute the ImageData object for rendering
        const canvasData = new ImageData(imageWidth, imageHeight);
        const data = canvasData.data;

        for (let i = 0; i < normalizedData.length; i++) {
          const pixelValue = normalizedData[i];
          const index = i * 4;
          data[index] = pixelValue;
          data[index + 1] = pixelValue;
          data[index + 2] = pixelValue;
          data[index + 3] = 255;
        }

        console.timeLog("renderMonochromeImage", "ImageData object created");

        // Step 6: Render the image on the canvas
        canvas.width = imageWidth;
        canvas.height = imageHeight;

        offscreenCanvas = document.createElement("canvas");
        offscreenCanvas.width = imageWidth;
        offscreenCanvas.height = imageHeight;
        offscreenCtx = offscreenCanvas.getContext("2d");
        offscreenCtx.putImageData(canvasData, 0, 0);

        ctx.drawImage(offscreenCanvas, 0, 0);
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.imageSmoothingEnabled = false;

        console.timeLog("renderMonochromeImage", "Image rendered");

        // rescale the canvas to fit the window
        scaleFactor = Math.min(
          window.innerWidth / imageWidth,
          window.innerHeight / imageHeight
        );
        canvas.style.width = `${imageWidth * scaleFactor - 100}px`;
        canvas.style.height = `${imageHeight * scaleFactor - 100}px`;

        spinner.style.display = "none";
        mainContainer.style.display = "grid";

        xProfileCanvas.width = canvas.getBoundingClientRect().width;
        yProfileCanvas.height = canvas.getBoundingClientRect().height;

        // set width of header-container to match the canvas width
        document.querySelector(".header-container").style.width = `${canvas.getBoundingClientRect().width}px`;

        // Add mousemove event listener to show pixel value and line profiles
        canvas.addEventListener("mousemove", (event) => {
          imageInteractionHandler(event, imageWidth, imageHeight);
        });
        canvas.addEventListener("wheel", (event) => {
          imageInteractionHandler(event, imageWidth, imageHeight);
        });
        canvas.addEventListener("pointermove", (event) => {
          imageInteractionHandler(event, imageWidth, imageHeight);
        });

        console.timeEnd("renderMonochromeImage", "Image rendered finished");
      }

      function imageInteractionHandler(event, width, height) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const x = Math.floor((event.clientX - rect.left) * scaleX);
        const y = Math.floor((event.clientY - rect.top) * scaleY);

        // Apply the current transform to get the actual pixel coordinates
        const transformedX = Math.floor(
          (x - currentTransform.x / scaleFactor) / currentTransform.k
        );
        const transformedY = Math.floor(
          (y - currentTransform.y / scaleFactor) / currentTransform.k
        );

        // current x width and y height in terms of pixels in the image
        const xWidth = Math.ceil(imageWidth / currentTransform.k);
        const yHeight = Math.ceil(imageHeight / currentTransform.k);

        // left and top of the image in terms of pixels in the image
        const left = Math.floor(
          -currentTransform.x / scaleFactor / currentTransform.k
        );
        const top = Math.floor(
          -currentTransform.y / scaleFactor / currentTransform.k
        );

        if (
          transformedX >= 0 &&
          transformedX < width &&
          transformedY >= 0 &&
          transformedY < height
        ) {
          // Extract X and Y line profiles of region shown in the canvas
          const xProfile = imageData.slice(
            transformedY * width + left,
            transformedY * width + left + xWidth + 1
          );
          const yProfile = imageDataT[transformedX].slice(
            top,
            top + yHeight + 1
          );

          // Draw line profiles
          drawLineProfile(
            xProfileCtx,
            xProfile,
            true,
            -currentTransform.x / scaleFactor / currentTransform.k - left
          );
          drawLineProfile(
            yProfileCtx,
            yProfile,
            false,
            -currentTransform.y / scaleFactor / currentTransform.k - top
          );

          // Show pixel value
          const pixelValue = formatNumber(imageData[transformedY * width + transformedX], 2);
          document.getElementById("pixelValue").innerText = `${pixelValue}`;
          document.getElementById(
            "pixelPosition"
          ).innerText = `${transformedX}, ${transformedY}`;
        }
      }

      function setupZoom() {
        const zoom = d3
          .zoom()
          .scaleExtent([1, 100]) // Zoom range
          .on("zoom", (event) => {
            // console.log("Zoom event", event.transform);
            let transform = event.transform;
            currentTransform = transform;

            // Constrain translation to prevent panning out of canvas
            const maxX = Math.max(
              0,
              (canvas.width - imageWidth * transform.k) / 2
            );
            const maxY = Math.max(
              0,
              (canvas.height - imageHeight * transform.k) / 2
            );
            transform.x = Math.min(
              maxX,
              Math.max(
                transform.x,
                canvas.width - imageWidth * transform.k - maxX
              )
            );
            transform.y = Math.min(
              maxY,
              Math.max(
                transform.y,
                canvas.height - imageHeight * transform.k - maxY
              )
            );

            // Compute visible canvas size and resample from the original resolution
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(transform.x / scaleFactor, transform.y / scaleFactor);
            ctx.scale(transform.k, transform.k);

            // Redraw the original image with the appropriate transformation
            ctx.drawImage(offscreenCanvas, 0, 0, imageWidth, imageHeight);
            ctx.restore();
          });

        d3.select(canvas).call(zoom);
      }

      console.time("loadData");
      window.addEventListener("message", (event) => {
        const message = event.data;
        if (message.command === "loadData") {
          renderMonochromeImage(message.fileUri);
          setupZoom(); // Initialize zoom after rendering
          console.timeEnd("loadData");
        }
      });

      vscode.postMessage({ command: "ready" });
    </script>
  </body>
</html>
